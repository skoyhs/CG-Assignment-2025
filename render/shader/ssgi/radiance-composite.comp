#version 460

#extension GL_GOOGLE_include_directive : enable
#include "../common/oct.glsl"
#include "../common/ndc-uv-conv.glsl"
#include "../common/pbr.glsl"
#include "../common/gbuffer-storage.glsl"
#include "../common/constant.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform usampler2D lighting_info_tex;
layout(set = 0, binding = 1) uniform sampler2D prev_radiance_tex;
layout(set = 0, binding = 2) uniform sampler2D prev_depth_tex;
layout(set = 0, binding = 3) uniform sampler2D depth_tex;
layout(set = 0, binding = 4) uniform sampler2D albedo_tex;

layout(set = 0, binding = 5) uniform sampler2D reservoir_tex1;
layout(set = 0, binding = 6) uniform usampler2D reservoir_tex2;
layout(set = 0, binding = 7) uniform usampler2D prev_reservoir_tex3;
layout(set = 0, binding = 8) uniform sampler2D reservoir_tex4;

layout(set = 1, binding = 0, rgba16f) uniform writeonly image2D out_radiance_tex;

layout(std140, set = 2, binding = 0) uniform Params
{
    mat4 back_projection_mat;
    mat4 inv_back_projection_mat;
    mat4 inv_view_proj_mat;
    mat4 inv_view_mat;
    uvec2 comp_resolution;
    uvec2 full_resolution;
    float blend_factor;
};

const ivec2 offsets[9] = ivec2[](
        ivec2(0, 0), ivec2(-1, 0), ivec2(1, 0),
        ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1),
        ivec2(-1, 1), ivec2(0, 1), ivec2(1, 1)
    );

void main()
{
    const ivec2 comp_coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 full_coord = comp_coord << 1;
    const ivec2 comp_resolution_ivec2 = ivec2(comp_resolution);
    if (any(greaterThanEqual(comp_coord, comp_resolution_ivec2))) return;

    float depth_tex_sample = texelFetch(depth_tex, full_coord, 0).r;
    if (depth_tex_sample == 0.0)
    {
        imageStore(out_radiance_tex, comp_coord, vec4(0.0));
        return;
    }

    const vec4 reservoir_tex1_sample = texelFetch(reservoir_tex1, comp_coord, 0);
    const uvec4 reservoir_tex2_sample = texelFetch(reservoir_tex2, comp_coord, 0);
    const vec4 reservoir_tex4_sample = texelFetch(reservoir_tex4, comp_coord, 0);
    const vec3 albedo = texelFetch(albedo_tex, full_coord, 0).rgb;

    // Reconstruct world position from full-res depth. Depth texture stores
    // post-projection depth in Vulkan's [0,1] NDC Z range (reverse-Z handled by proj).
    const vec2 ndc_xy = uv_to_ndc((vec2(full_coord) + 0.5) / vec2(full_resolution));
    const float ndc_z = depth_tex_sample;
    const vec4 W_curr_pos_h = inv_view_proj_mat * vec4(ndc_xy, ndc_z, 1.0);
    const vec3 W_curr_pos = W_curr_pos_h.xyz / W_curr_pos_h.w;
    const vec3 hit_luminance = reservoir_tex4_sample.rgb;
    const vec3 W_hit_position = vec3(
            uintBitsToFloat(reservoir_tex2_sample.x),
            uintBitsToFloat(reservoir_tex2_sample.y),
            uintBitsToFloat(reservoir_tex2_sample.z)
        );
    const float W = reservoir_tex1_sample.z;
    const GBufferLighting lighting = unpack_gbuffer_lighting(texelFetch(lighting_info_tex, full_coord, 0).xy);
    const vec3 W_curr_normal = lighting.normal;
    const vec2 roughness_metalness = vec2(lighting.roughness, lighting.metalness);

    const vec4 P_prev_h = back_projection_mat * vec4(W_curr_pos, 1.0);
    const vec3 NDC_prev = P_prev_h.xyz / P_prev_h.w;
    const vec2 UV_pixel_unit = 2.0 / vec2(full_resolution);

    const vec3 curr_luminance = hit_luminance * W;
    const vec3 W_light_dir = normalize(W_hit_position - W_curr_pos);
    const vec3 view_dir = normalize(W_curr_pos - inv_view_mat[3].xyz);
    vec3 radiance = gltf_calculate_pbr(
            W_light_dir,
            curr_luminance,
            -view_dir,
            W_curr_normal,
            albedo,
            mix(0.04, 1.0, roughness_metalness.x),
            roughness_metalness.y
        ) * PI;
    radiance = clamp(radiance, vec3(0.0), vec3(65504.0));

    vec3 prev_radiance = vec3(0.0);

    if (P_prev_h.w > 0.0 && all(lessThanEqual(abs(NDC_prev.xy), vec2(1.0))))
    {
        const vec2 UV_prev = ndc_to_uv(NDC_prev.xy);
        const float prev_depth_sample = textureLod(prev_depth_tex, UV_prev, 0.0).r;

        if (distance(prev_depth_sample, NDC_prev.z) / prev_depth_sample < 0.01)
        {
            const ivec2 PUV_prev = ivec2(floor(UV_prev * vec2(comp_resolution)));
            float min_distance = FLT_HIGHEST;
            int min_distance_index;

            for (int i = 0; i < 9; ++i)
            {
                const ivec2 neighbor_coord = PUV_prev + offsets[i];

                if (any(lessThan(neighbor_coord, ivec2(0))) ||
                        any(greaterThanEqual(neighbor_coord, comp_resolution_ivec2)))
                {
                    continue;
                }

                const uvec3 neighbor_tex3_sample = texelFetch(prev_reservoir_tex3, neighbor_coord, 0).xyz;
                const vec3 neighbor_start_position = vec3(
                        uintBitsToFloat(neighbor_tex3_sample.x),
                        uintBitsToFloat(neighbor_tex3_sample.y),
                        uintBitsToFloat(neighbor_tex3_sample.z)
                    );
                const float distance_to_neighbor = distance(W_curr_pos, neighbor_start_position);

                if (distance_to_neighbor < min_distance)
                {
                    min_distance = distance_to_neighbor;
                    min_distance_index = i;
                }
            }

            prev_radiance = texelFetch(prev_radiance_tex, PUV_prev + offsets[min_distance_index], 0).rgb;
        }
    }

    radiance = mix(prev_radiance, radiance, blend_factor);

    imageStore(out_radiance_tex, comp_coord, vec4(radiance, 1.0));
}
