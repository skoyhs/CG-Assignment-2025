// Compute weighted bin histogram of log-luminance values

#version 460

#extension GL_EXT_samplerless_texture_functions : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D mask_tex;
layout(set = 0, binding = 1) uniform texture2D input_image;

layout(std430, set = 1, binding = 0) buffer Dst
{
    uint bins[256];
    uint weight_sum;
};

layout(std140, set = 2, binding = 0) uniform Params
{
    float min_histogram_value;
    float log_min_histogram_value; // = log2(min)
    float dynamic_range; // = log2(max) - log2(min)
    uvec2 input_size;
};

shared uint weight_sum_shared;
shared uint bins_shared[256];

void main()
{
    // Outside the input image bounds: return if either coordinate is out-of-range
    if (any(greaterThanEqual(gl_GlobalInvocationID.xy, input_size)))
        return;

    /* Clear the shared memory */

    if (gl_LocalInvocationIndex == 0) weight_sum_shared = 0;
    bins_shared[gl_LocalInvocationIndex] = 0;

    barrier();

    /* Calculate */

    vec3 color = texelFetch(input_image, ivec2(gl_GlobalInvocationID.xy), 0).rgb;
    float luminance = dot(color, vec3(0.2126, 0.7152, 0.0722));
    luminance = max(luminance, min_histogram_value);
    float log_luminance = log2(luminance);

    uint weight = uint(floor(textureLod(mask_tex, (vec2(gl_GlobalInvocationID.xy) + 0.5) / vec2(input_size), 0).r * 255));

    float percentage = clamp(
            (log_luminance - log_min_histogram_value) / dynamic_range,
            0.0, 1.0
        );

    uint pos_f = uint(floor(percentage * 255.9));

    atomicAdd(bins_shared[pos_f], weight);
    atomicAdd(weight_sum_shared, weight);
    barrier();

    /* Write back to global memory */

    if (gl_LocalInvocationIndex == 0) atomicAdd(weight_sum, weight_sum_shared);
    atomicAdd(bins[gl_LocalInvocationIndex], bins_shared[gl_LocalInvocationIndex]);
}
